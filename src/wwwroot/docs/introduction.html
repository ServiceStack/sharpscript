<!--
title: Introduction
order: 2
-->

<p>
    SharpScript is a simple and elegant, <a href="/docs/methods">highly-extensible</a>, <a href="/docs/sandbox">sandboxed</a>, 
    high-performance <a href="/docs/page-formats">general-purpose</a> templating engine for .NET 4.5 and .NET Core. 
    It's designed from the ground-up to be incrementally adoptable where its basic usage is simple enough 
    for non-technical users to use whilst it progressively enables access to more power and functionality allowing it to scale up to 
    support full server-rendering Web Server workloads and beyond. Its high-fidelity with JavaScript syntax allows it to use a common
    language for seamlessly integrating with client-side JavaScript Single Page App frameworks where its syntax is designed to be 
    compatible with <a href="https://vuejs.org/v2/guide/syntax.html#Filters">Vue filters</a>.
</p>

<h3>Quick walk through</h3>

<p>
    To render the pages we first create and initialize a <em>ScriptContext</em>
</p>

{{ 'gfm/introduction/01.md' | githubMarkdown }}

<p>
    The ScriptContext is the sandbox where all scripts are executed within, everything your script has access to and generates 
    is maintained within the ScriptContext. Once initialize you can start using it to evaluate scripts which you can do with:
</p>

{{ 'gfm/introduction/02.md' | githubMarkdown }}


<p>
    Scripts only have access to script methods, blocks and arguments defined within its Context, which for an empty Context are
    the comprehensive suite of safe <a href="/docs/default-scripts">Default Scripts</a> and <a href="/docs/html-scripts">HTML Scripts</a>.
</p>

<h5 id="rendering-pages">Rendering Script Pages</h5>

<p>
    Behind the scenes this creates a dynamic page with your Script and uses the <em>PageResult</em> to render it to a string:
</p>

{{ 'gfm/introduction/09.md' | githubMarkdown }}

<h4 id="evaluate-return-values">Evaluating Scripts with return values</h4>

<p>
    Sharp Scripts can be used to either render text as above, they can also have return values with the <em>return</em> method
    which can be accessed using the <em>Evaluate()</em> API:
</p>

{{ 'gfm/introduction/10.md' | githubMarkdown }}

<h4>Multi page Scripts</h4>

{{ "live-pages" | partial(
    {
        page: 'page', 
        files: 
        { 
            '_layout.html': 'I am the Layout: <b>{{ page }}</b>',   
            'page.html' : 'I am the Page' 
        } 
    }) 
}}


<p>
    Typically you'll want to use SharpScript to render entire pages which are sourced from its configured
    <a href="https://docs.servicestack.net/virtual-file-system">Virtual File System</a> which uses an In Memory Virtual 
    File System by default that we can programmatically populate:
</p>

{{ 'gfm/introduction/03.md' | githubMarkdown }}
    
<p>
    Pages are rendered using a <em>PageResult</em> essentially a rendering context that needs to be provided the Page to render:
</p>

{{ 'gfm/introduction/04.md' | githubMarkdown }}

<p>
    The script page output can then be asynchronously rendered to any Stream:
</p>

{{ 'gfm/introduction/05.md' | githubMarkdown }}

<p>
    Or to access the output as a string you can use the convenience extension method:
</p>

{{ 'gfm/introduction/06.md' | githubMarkdown }}

<p>
    All I/O within SharpScript is non-blocking, but if you're evaluating an adhoc script or using the default In Memory Virtual FileSystem 
    there's no I/O so you can safely block to get the generated output with:
</p>

{{ 'gfm/introduction/07.md' | githubMarkdown }}

<p>
    Both APIs returns the result you see in the Live Example above.
</p>
    
<h4 id="cascading-resolution">Cascading Resolution</h4>

<p>
    There's no forced special centralized folders like <em>/Views</em> or <em>/Views/Shared</em> required to store layouts or share partials or 
    artificial "Areas" concept to isolate website sections. Different websites or sections are intuitively grouped into different 
    folders and SharpScript automatically resolves the closest layout it finds for each page. Cascading resolution also applies to 
    including files or partial pages where you can use just its name to resolve the closest one, or an absolute path from the 
    <em>WebRootPath</em> to include a specific partial or file from a different folder.
</p>

<h3>High-level, Declarative and Intent-based</h3>

<p>
    High-level APIs are usually synonymous with being slow by virtue of paying a penalty for their high-level abstraction,
    but in the domain of I/O and Streams such-as rendering text to Streams they make it trivial to compose high-level functionality
    that's implemented more efficiently than would be typically written in C# / ASP.NET MVC Apps.
</p>

<p>
    As an example let's analyze the script below:
</p>

{{ 'gfm/introduction/08.md' | githubMarkdown }}

<p>
    The intent of SharpScript code should be clear even if it's the first time reading it. From left-to-right we can deduce that it
     retrieves a url from the quote table, downloads its contents of and converts it to markdown before replacing the text "Razor" and
     "2010" and displaying the <em>raw</em> non-HTML encoded html output. 
</p>

<h5>Implementation using ASP.NET MVC</h5>
<p>
    In MVC the typical and easiest approach would be to create a an MVC Controller Action, use EF to make a sync call to access the database,
    a sync call with a new HTTP Client to download the content which is buffered inside the Controller action before returned inside a View Model
    that is handed off to MVC to execute the View inside the default Layout.
</p>

<h5>Implementation using SharpScript</h5>
<p>
    What does SharpScript do? lets step through the first filter:
</p>

{{ "live-template" | partial({ output:'no-scroll', rows:1, template: "{{ 'select url from quote where id= @id' | dbScalar({ id:1 }) | htmlLink }}" }) }}

<p>
    What filter implementation gets called depends on which <a href="/docs/db-scripts">DB Scripts</a> is registered, if your RDBMS supports ADO.NET's 
    async API you can register 
    <a href="https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/src/ServiceStack.OrmLite/DbScriptsAsync.cs">DbScriptsAsync</a>
    to execute all queries asynchronously, otherwise if using an RDBMS whose ADO.NET Provider doesn't support async you can register the
    <a href="https://github.com/ServiceStack/ServiceStack.OrmLite/blob/master/src/ServiceStack.OrmLite/DbScripts.cs">DbScripts</a>
    to execute each DB request synchronously without paying for any <i>pseudo-async</i> overhead, in each case the exact same code executes
    the most optimal ADO.NET APIs. SharpScript also benefits from using the much faster 
    <a href="https://github.com/ServiceStack/ServiceStack.OrmLite">OrmLite</a> and also saves on the abstraction cost from generating a 
    parameterized SQL Statement from a Typed Expression-based API.    
</p>

<h5>Arguments chain</h5>
<p>
    The next question becomes what is <em>id</em> bound to? Similar to JavaScript's prototype chain it resolves the closest 
    argument in its <a href="/docs/arguments">Arguments hierarchy</a>, e.g. when evaluated as a view page it could be set 
    by arguments in [paged based routes](/docs/sharp-pages#page-based-routing) or when the same page is evaluated as a 
    partial it could be set from the scoped arguments it was called with.
</p>

<h5>Async I/O</h5>
<p>
    The url returned from the db is then passed to the <em>urlContents</em> filter which if it was the last filter in the expression
    avoids any buffering by asynchronously streaming the url content stream directly to the forward-only HTTP Response Stream:
</p>

<pre class="cs"><code>{{ pass: url | urlContents }}</code></pre>

<p>
    <em>urlContents</em> is a <a href="/docs/methods#block-methods">Block Method</a> which instead of returning a value writes its 
    response to the OutputStream it's given. But then how could we convert it to Markdown if it's already written to the Response Stream?
    SharpScript analyzes the Expression's AST to determine if there's any filters remaining, if there is it gives the <em>urlContents</em> 
    Block filter a <em>MemoryStream</em> to write to, then forwards its buffered output to the next filter. Since they don't return values, 
    the only thing that can come after a Block Filter are other Block filters or <a href="/docs/transformers">Stream Transformers</a>. 
    <em>markdown</em> is one such <a href="/docs/transformers#filter-transformers">Filter Transformer</a> which takes in a stream of Markdown 
    and returns a Stream of HTML.
</p>

<pre class="cs"><code>{{ pass: url | urlContents | markdown }}</code></pre>

<h5>Same intent, different implementations</h5>
<p>
    The <em>assignTo</em> filter is used to set a value in the current scope. After Block Filters, a different <em>assignTo</em> Block Filter
    is used with the same name and purpose but a different implementation that reads all the contents of the stream into a UTF-8 string
    and sets a value in the current scope before returning an empty Stream so nothing is written to the Response. 
</p>

<pre class="cs"><code>{{ pass: url | urlContents | markdown | assignTo: quote }}</code></pre>

<p>
    Once the streamed output is captured and assigned it goes back into becoming a normal argument that opens it up to be 
    able to use all filters again, which is how we're able to use the string <em>replace</em> filters before rendering the final result :)
</p>

<h4><a href="/examples/qotd?id=1">/examples/qotd?id=1</a></h4>

<h5>Using the most efficient implementation allowable</h5>
<p>
    So whilst it conceptually looks like each filter is transforming large buffered strings inside every filter, the expression is 
    inspected to utilize the most efficient implementation allowable. At the same time filters are not statically bound to 
    any implementation so you could for instance <a href="/docs/methods#registering-methods">insert a Custom Filter</a> before the Default 
    Filters containing the same name and arguments count to have SharpScript execute your custom script methods instead, all whilst the  
    script source code and intent remains untouched.
</p>

<h5>Intent-based code is easier to augment</h5>
<p>
    If it was later discovered that some URLs were slow or rate-limited and you needed to introduce caching, your original C# code
    would require a fair amount of rework, in SharpScript you can simply add <em>WithCache</em> to call the
    <a href="/docs/protected-scripts#includeurlwithcache">urlContentsWithCache</a> filter to return locally cached contents 
    on subsequent requests.
</p>

<pre class="cs"><code>{{ pass: url | urlContentsWithCache | markdown }}</code></pre>

<h4>Simplified Language</h4>

<p>
    As there's very little ceremony in SharpScript, a chain of filters looks like it's using its own DSL to accomplish each task and
    given <a href="/docs/methods#registering-methods">implementing and registering custom filters </a> is trivial you're 
    encouraged to write the intent of your code first then implement any filters that are missing to realize its intent. Once 
    you've captured the intent of what you want to do, it's less likely to ever need to change, focus is instead on 
    fixing any bugs and making the filter implementations as efficient as possible, which benefits all existing code using the same filter.
</p>

<p>    
    To improve readability and make it more approachable, SharpScript aims to normalize the mechanics of the underlying implementation from 
    the code's intent so you can use the same syntax to access an argument, e.g. <em>{{ pass: arg }}</em> as you would a filter without 
    arguments  <em>{{ pass: now }}</em> and just like JavaScript you can use <em>obj.Property</em> syntax to access both a public property 
    on a Type or an entry in a Dictionary.
</p>

<h3 id="late-bound">Late-bound flexibility</h3>

<p>
    There's no static coupling to concrete classes, static methods or other filters, ambiguous method exceptions or namespace collisions. 
    Each filter is self-contained and can easily be shared and dropped into any Web App by 
    <a href="/docs/methods#registering-methods">registering them in a list</a>. Inspired by the power and 
    <a href="http://mythz.servicestack.net">flexibility in Smalltalk and LISP</a>, filters are late-bound at run-time to the first matching filter 
    in the user-defined list of <em>ScriptMethods</em>. This ability to shadow filters enables high-level intent-based APIs decoupled from implementations which 
    <a href="/docs/servicestack-scripts#sendToAutoQuery-rdbms">sendToAutoQuery</a> leverages to automatically route filter invocations to 
    the appropriate implementation depending of if it's an <a href="https://docs.servicestack.net/autoquery-rdbms">AutoQuery RDBMS</a> or an 
    <a href="https://docs.servicestack.net/autoquery-data">AutoQuery Data</a> request, masking their implementations as a transparent detail. 
    This flexibility also makes it easy create proxies, intercept and inject behavior like logging or profiling without modifying existing 
    script method implementations or script source code.
</p>

{{ "doc-links" | partial({ order }) }}
