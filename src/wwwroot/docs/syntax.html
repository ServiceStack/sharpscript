<!--
title: Syntax
order: 3
-->

<p>
    <em>#Script</em> aims to be a familiar and expressive dynamic language for scripting .NET Apps, that is optimal 
    at generating text, especially HTML where it's pre-configured with the
    <a href="/docs/page-formats">HTML Page Format</a> and <a href="/docs/html-scripts">HTML Scripts</a> but
    unlike C#'s Razor can support multiple pluggable page formats which can be used for generating any kind of text.
</p>

<p>
    For maximum familiarity #Script uses <a href="/docs/expression-viewer">JavaScript Expressions</a> 
    that for increased readability and expressiveness supports being used within Template Expressions
    which like <a href="https://vuejs.org/v2/guide/syntax.html#Filters">Vue.js filters</a>,
    and <a href="https://angular.io/guide/template-syntax#template-expression-operators">Angular's Template Expressions</a>
    lets you use the <em>|</em> pipe operator to chain the return values of methods into subsequent methods from left-to-right.
    For statements #Script adopts the familiar Handlebars-like
    <a href="/docs/blocks">Script Blocks</a> that is also popular among HTML templating engines.
</p>

<p>
    Effectively #Script lets you use the same familiar JS language for server HTML rendering as you would do
    in client-side rendering of Single Page Apps despite it binding natively to C# objects and calling C# methods behind-the-scenes.
</p>

<h4>Mustache expressions</h4>

<p>
    Like Vue/Angular Templates, only expressions inside mustaches are evaluated, whilst everything outside are emitted as-is:
</p>

{{ 'live-template' | partial({ template: "outside <i>{{ 'shout' | upper }}</i> text" }) }}

<p>
    Which calls the <em>upper</em> default script method where the argument on the left-side of the "pipe" symbol is 
    passed as the first argument to the upper method which is implemented as:
</p>

{{ 'gfm/syntax/01.md' | githubMarkdown }}

<p>
    This can also be rewritten without the "pipe" symbol by calling the method with an argument instead:
</p>

{{ 'live-template' | partial({ template: "outside <i>{{ upper('shout') }}</i> text" }) }}

<h4>Methods can be chained</h4>

<p>
    Methods are chained from left-to-right where the value on the left side of the "pipe" symbol is passed as the first 
    argument in the method on the right and the output of that is passed as the input of the next method in the chain and so on:
</p>

{{ 'live-template' | partial({ template: "{{ 'shout' | upper | substring(2) | padRight(6, '_') | repeat(3) }}" }) }}

<p>
    Methods can also accept additional arguments which are passed starting from the 2nd argument since the first 
    argument is the value the method is called with. E.g. here are the implementations for the <em>substring</em> and 
    <em>padRight</em> default scripts:
</p>

{{ 'gfm/syntax/02.md' | githubMarkdown }}

<h4 id="javascript-literals">JavaScript literal notation</h4>

<p>
    You can use the same literal syntax used to define numbers, strings, booleans, null, Objects and Arrays in JavaScript
    within templates and it will get converted into the most appropriate .NET Type, e.g:
</p>

{{ 'live-template' | partial({ rows: 8, template: "{{ null               | typeName }}
{{ true               | typeName }}
{{ 1                  | typeName }}
{{ 1.1                | typeName }}
{{ 'string'           | typeName }}
{{ ['array', 'items'] | typeName }}
{{ { key: 'value' }   | typeName }}
" }) }}

<p>
    ES6 Shorthand notation is also supported where you can use the argument name as its property name in a Dictionary:
</p>

{{ 'live-template' | partial({ template: "{{ 'foo'    | to => bar }}
{{ { bar }  | to => obj }}
{{ obj['bar'] }}" }) }}

<h4>Quotes</h4>

<p>
    Strings can be defined using single quotes, double quotes, prime quotes or backticks:
</p>

{{ 'live-template' | partial({ rows:4, template: "{{ \"double quotes\" }}
{{ 'single quotes' }}
{{ ′prime quotes′ }}
{{ `backticks` }}" }) }}

<blockquote>
    Strings can also span multiple lines.
</blockquote>

<h4>Template Literals</h4>

Backticks strings implement <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">JavaScript's Template literals</a>
which can be be used to embed expressions:

{{ 'live-template' | partial({ rows:4, template: "{{ `Time is ${now}, expr= ${true ? pow(1+2,3) : ''}` }}
Prime Quotes     {{ now.TimeOfDay | timeFormat(′h\\:mm\\:ss′) }}
Template Literal {{ now.TimeOfDay | timeFormat(`h\\\\:mm\\\\:ss`) }}" }) }}

The example above also shows the difference in escaping where Template literals evaluate escaped characters whilst normal strings 
leave <em>\</em> backspaces unescaped.

<h4>Shorthand arrow expression syntax</h4>

<p>
    Template Expressions have full support for JavaScript expressions but doesn't support statements or function declarations although it 
    does support JavaScript's arrow function expressions which can be used in functional methods to enable LINQ-like queries.
    You can use fat arrows <em>=></em> immediately after methods to define lambda's with an implicit <em>(it => ...)</em> binding, e.g:
</p>

{{ 'live-template' | partial({ template: ′{{ [0,1,2,3,4,5]
   | where => it >= 3
   | map => it + 10 | join(`\n`) }}′ }) }}

<p>
    This is a shorthand for declaring lambda expressions with normal arrow expression syntax:
</p>

{{ 'live-template' | partial({ template: ′{{ [0,1,2,3,4,5]
    | where(it => it >= 3)
    | map(x => x + 10) | join(`\n`) }}′ }) }}
 
<p>
    Using normal lambda expression syntax lets you rename lambda parameters as seen in the <em>map(x => ...)</em> example.
</p>

<h4>Special string argument syntax</h4>

<p>
    As string expressions are a prevalent in <em>#Script</em>, we've also given them special wrist-friendly syntax where you
    can add a colon at the end of the method name which says to treat the following characters up until the end of the
    line or mustache expression as a string, trim it and convert '{' and '}' chars into mustaches. With this syntax
    you can write:
</p>

{{ 'live-template' | partial({ template: "{{ [3,4,5] | select: { it | incrBy(10) }\\n }}" }) }}

<p>
    and it will be rewritten into its equivalent and more verbose form of:
</p>

{{ 'live-template' | partial({ template: "{{ [3,4,5] | select(′{{ it | incrBy(10) }}\\n′) }}" 
}) }}

<h4>SQL-like Boolean Expressions</h4>

<p>
    To maximize readability and intuitiveness for non-programmers, boolean expressions can also adopt an SQL-like syntax where
    instead of using <em>&amp;&amp;</em>, <em>||</em> or <em>==</em> operator syntax to define boolean expressions you can also
    use the more human-friendly <em>and</em>, <em>or</em> and <em>=</em> alternatives:
</p>

{{ 'live-template' | partial({ template: "{{ [0,1,2,3,4,5] 
   | where => (it = 2 or it = 3) and it.isOdd()
   | join }}" }) }}

<h4>Include Raw Content Verbatim</h4>

Use <em>#raw</em> blocks to ignore evaluating expressions and emit content verbatim. This is useful when using a
client Handlebars-like templating solution like Vue or Angular templates where expressions need to be evaluated 
with JavaScript in the browser instead of on the Server with Templates:

{{ 'live-template' | partial({ rows: 4, template: "{{#raw}}Hi {{ person.name }}, Welcome to {{ site.name }}!{{/raw}}

{{#raw template}}Assign contents with {{ expressions }} into 'template' argument{{/raw}}
Captured Argument: {{template}}" 
 }) }}

<h4>Multi-line Comments</h4>

<p>
    Any text within <em>{{#raw}}{{#noop}} ... {{/noop}}{{/raw}}</em> block statements are ignored and can be used for temporarily removing
    sections from pages without needing to delete it.
</p>

<p>
    Everything within multi-line comments <em>{{#raw}}{{&zwnj;*</em> and <em>*&zwnj;}}{{/raw}}</em> is ignored and removed from the page.
</p>

<p>
    An alternative way to temporarily disable an expression is to prefix the expression with the <em>end</em> method to 
    immediately short-circuit evaluation, e.g: <em>{{#raw}}{{ end | now | dateFormat }}{{/raw}}</em>
</p>

<p>
    See <a href="/docs/sharp-pages#ignoring-pages">Ignoring Pages</a> for different options for ignoring entire pages and 
    layout templates.
</p>

<a name="extension-methods"></a>
{{#markdown}}

### Script Methods can be used as Extension Methods

A core feature of `#Script` is that it runs in a [sandbox](/sandbox) and only has access to functionality that's configured in its `ScriptContext`
that it runs in, so by design `#Script` is prohibited from calling instance methods so they only have a read-only view of your objects
unless you explicitly register `ScriptMethods` that allows them to change them. 

This frees up the `instance.method()` syntax to be put to other use which can now be used to call every script method as an extension method.
This can greatly improve the readability and execution flow of code, e,g. we can rewrite our previous 
[JS Utils Eval](https://docs.servicestack.net/js-utils#eval) example:

    itemsOf(3, padRight(reverse(arg), 8, '_'))

into the more readable form using the same methods as extension methods off the first argument, e.g:

    3.itemsOf(arg.reverse().padRight(8, '_'))

{{/markdown}}

{{ 'gfm/syntax/04.md' | githubMarkdown }}

{{#markdown}}

### JavaScript Array Support

We can use extension methods to define instance methods that can be called on any object to implement JS Array methods support 
to further improve `#Script` source compatibility with JavaScript. 

Here are [Mozilla's Array examples](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array) in `#Script`
utilizing its [Code Blocks](#code-blocks) feature to reduce the amount of boilerplate required:

{{/markdown}}

{{ 'gfm/syntax/03.md' | githubMarkdown | convertScriptToCodeBlocks }}

{{#markdown}}

Which can be run with `web run {script}.ss` to view its expected output:

    Create an Array
    2

    Access (index into) an Array Item
    Apple

    Loop over an Array
    Apple, 0
    Banana, 1

    Apple, 0
    Banana, 1

    Add to the end of an Array
    3

    Remove from the end of an Array
    Orange

    Remove from the front of an Array
    Apple

    Add to the front of an Array
    2

    Find the index of an item in the Array
    1

    Remove an item by index position
    Banana
    Strawberry,Mango

    Remove items from an index position
    Cabbage,Turnip,Radish,Carrot
    Cabbage,Carrot
    Turnip,Radish

    Copy an Array
    Strawberry,Mango

Most JS Array methods are supported, including the latest additions from ES2019:

 - `concat`
 - `every`
 - `filter`
 - `find`
 - `findIndex`
 - `flat`
 - `flatMap`
 - `forEach`
 - `includes`
 - `indexOf`
 - `join`
 - `keys`
 - `lastIndexOf`
 - `map`
 - `pop`
 - `push`
 - `reduce`
 - `reverse`
 - `shift`
 - `slice`
 - `some`
 - `sort`
 - `splice`
 - `toString`
 - `unshift`
 - `values`


### Code Blocks

We've caught a glimpse of `#Script` new `code` blocks feature in the JavaScript Array Example above which dramatically reduces
the boilerplate that would've otherwise been needed where each statement would've needed to be wrapped in an expression block. 

They're akin to Razor's statement blocks which inverts Razor's **mode** of emitting text to treating text inside statement blocks as code, e.g:

{{/markdown}}

{{ 'gfm/syntax/05.md' | githubMarkdown | convertScriptToCodeBlocks }}

{{#markdown}}

The entire **code** feature is implemented within a
[simple TransformCodeBlocks PreProcessor](https://github.com/ServiceStack/ServiceStack/blob/master/src/ServiceStack.Common/Script/ScriptPreprocessors.cs) 
that's pre-configured by default and so can be removed by clearing the `Preprocessors` List:

    var context = new ScriptContext();
    context.Preprocessors.Clear();

#### Preprocessor Code Transformations

It performs a basic transformation that assumes every statement is an expression and wraps them in an `{{...}}` 
expression block, the exception are expressions which are already within an expression block which are ignored and you still
need to use to wrap multi-line expressions in `code` blocks.

The other transformation `code` blocks perform is collapsing new lines and trimming each line, this is so scripts which are primarily 
structured and indented for readability aren't reflected in its text output. 

We can see an example of how `code` blocks work from the example below:
{{/markdown}}

{{ 'gfm/syntax/06.md' | githubMarkdown | convertScriptToCodeBlocks }}


{{ "doc-links" | partial({ order }) }}
